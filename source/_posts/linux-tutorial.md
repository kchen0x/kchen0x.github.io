title: Linux 使用教程
date: 2016/4/16/ 14:17:00
tag:
	- Linux

---

> 笔记来源于[实验楼](http://www.shiyanlou.com)的Linux基础教程。

## 一、Linux学习路线

![LinuxRoute](https://dn-anything-about-doc.qbox.me/linux_base/1-8.png)

Unix族谱：

![UnixFamily](https://dn-anything-about-doc.qbox.me/linux_base/1-9.svg)

<!--more-->

## 二、基本概念及操作

几个大家熟知也最流行的实现了客户端功能的桌面环境KDE，GNOME，XFCE，LXDE，其中就有你看到的，实验楼目前使用的 XFCE 桌面环境，部分老用户可能可以回想起，实验楼之前使用的环境是 LXDE。这也意味着在 Linux 上你可以自己选择安装不同的桌面环境，甚至可以定制自己的专属桌面。

几个比较常见的终端模拟器，例如 gnome-terminal，kconsole，xterm，rxvt，kvt，nxterm 和 eterm。

终端本质上是对应着 Linux 上的 /dev/tty 设备，Linux 的多用户登陆就是通过不同的 /dev/tty 设备完成的，Linux 默认提供了 6 个纯命令行界面的 “terminal”（准确的说这里应该是 6 个 virtual consoles）来让用户登录，在物理机系统上你可以通过使用[Ctrl]+[Alt]+[F1]～[F6]进行切换，不过在我们的在线实验环境中可能无法切换，因为特殊功能按键会被你主机系统劫持。当你切换到其中一个终端后想要切换回图形界面，你可以按下[Ctrl]+[Alt]+[F7]来完成。

在 UNIX/Linux 中比较流行的常见的 Shell 有 bash，zsh，ksh，csh 等等，Ubuntu 终端默认使用的是 bash，默认的桌面环境是 GNOME 或者 Unity（基于 GNOME）

通配符是一种特殊语句，主要有星号（`*`）和问号（`?`），用来对对字符串进行模糊匹配（比如文件名，参数名）。当查找文件夹时，可以使用它来代替一个或多个真正字符；当不知道真正字符或者懒得输入完整名字时，常常使用通配符代替一个或多个真正的字符。

在创建文件的时候，如果需要一次性创建多个文件，比如：“love_1_linux.txt，love_2_linux.txt，... love_10_linux.txt”。在 Linux 中十分方便：

```bash
$ touch love_{1..10}_linux.txt
```

Shell 常用通配符：

| 字符 | 含义 |
|---|---|
| `*` | 匹配 0 或多个字符 |
| `?` | 匹配任意一个字符 |
| `[list]` | 匹配 list 中的任意单一字符 |
| `[!list]` | 匹配 除list 中的任意单一字符以外的字符 |
| `[c1-c2]` | 匹配 c1-c2 中的任意单一字符 如：`[0-9]` `[a-z]` |
| `{string1,string2,...}` | 匹配 sring1 或 string2 (或更多)其一字符串 |
| `{c2..c2}` | 匹配 c1-c2 中全部字符 如`{1..10}` |

## 三、用户及文件权限管理

请打开终端，输入命令：

```bash
$ who am i
或者
$ who mom likes
```

输入的第一列表示打开当前伪终端的用户的用户名（要查看当前登录用户的用户名，去掉空格直接使用 `whoami` 即可），第二列的 `pts/0` 中 `pts` 表示伪终端，所谓伪是相对于 `/dev/tty` 设备而言的，还记得上一节讲终端时的那七个使用 `[Ctrl]+[Alt]+[F1]～[F7]` 进行切换的 `/dev/tty` 设备么,这是“真终端”，伪终端就是当你在图形用户界面使用 `/dev/tty7` 时每打开一个终端就会产生一个伪终端， `pts/0` 后面那个数字就表示打开的伪终端序号，你可以尝试再打开一个终端，然后在里面输入 `who am i` ，看第二列是不是就变成 `pts/1` 了，第三列则表示当前伪终端的启动时间。

`su <user>`可以切换到用户user，执行时需要输入目标用户的密码，`sudo <cmd>`可以以特权级别运行cmd命令，需要当前用户属于sudo组，且需要输入当前用户密码。`su - <user>`命令也是切换用户，同时环境变量也会跟着改变成目标用户的环境变量。

使用 usermod 命令可以为用户添加用户组，同样使用该命令你必需有 root 权限，你可以直接使用 root 用户为其它用户添加用户组，或者用其它已经在 sudo 用户组的用户使用 sudo 命令获取权限来执行该命令

```bash
$ su shiyanlou
$ groups lilei
$ sudo usermod -G sudo lilei
$ groups lilei
```

文件权限

![详情](https://dn-anything-about-doc.qbox.me/linux_base/3-9.png)

![权限](https://dn-anything-about-doc.qbox.me/linux_base/3-10.png)

## 四、目录结构及文件基本操作

![Linux目录结构](https://dn-anything-about-doc.qbox.me/linux_base/4-1.png)

FHS（英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准），多数 Linux 版本采用这种文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。

FHS 定义了两层规范，第一层是， / 下面的各个目录应该要放什么文件数据，例如 /etc 应该要放置设置文件，/bin 与 /sbin 则应该要放置可执行文件等等。

第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统登录文件、/usr/share 放置共享数据等等。

使用 -p 参数，同时创建父目录（如果不存在该父目录），如下我们同时创建一个多级目录（这在有时候安装软件，配置安装路径时非常有用）：

`$ mkdir -p father/son/grandson`

可以加上-n参数显示行号：

`$ cat -n passwd`

如果说上面的 cat 是用来快速查看一个文件内容的，那么这个more和less就是天生用来"阅读"一个文件的内容的，比如说"man"手册内部就是使用的 less 来显示内容。其中more命令比较简单，只能向一个方向滚动，而"less"为基于"more"和"vi"开发，功能更强大。less 的使用基本和 more 一致。

只看一行， 加上-n参数，后面紧跟行数：

`$ tail -n 1 /etc/passwd`

关于`tail`命令，不得不提的还有它一个很牛的参数`-f`，这个参数可以实现不停地读取某个文件的内容并显示。这可让我们动态查看日志起到实时监视的作用。

如果你想更加快速的入门，你可以直接使用 Linux 内部的 vim 学习教程，输入如下命令即可开始：

`$ vimtutor`

## 五、环境变量与文件查找

通常我们会涉及到的环境变量有三种：

- 当前 Shell 进程私有用户自定义变量，如上面我们创建的 temp 变量，只在当前 Shell 中有效。
- Shell 本身内建的变量。
- 从自定义变量导出的环境变量。

也有三个与上述三种环境变量相关的命令，`set`，`env`，`export`。这三个命令很相似，都可以用于打印相关环境变量,区别在于涉及的是不同范围的环境变量，详见下表：

![环境变量作用域大小](https://dn-anything-about-doc.qbox.me/linux_base/5-3.png)

在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等等。zsh 的配置文件是.zshrc，相应 Bash 的配置文件为.bashrc。它们在etc下还都有一个或多个全局的配置文件，不过我们一般只修改用户目录下的配置文件。

我们可以简单的使用下面命令直接添加内容到.zshrc中：

`$ echo "PATH=$PATH:/home/shiyanlou/mybin" >> .zshrc`

> 上述命令中`>>`表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的`>`是以覆盖的方式重定向到一个文件中，使用的时候一定要注意分辨。在指定文件不存在的情况下都会创建新的文件。

在上面我们在 Shell 中修改了一个配置脚本文件之后（比如 zsh 的配置文件 home 目录下的.zshrc），每次都要退出终端重新打开甚至重启主机之后其才能生效，很是麻烦，我们可以使用`source`命令来让其立即生效，如：

`$ source .zshrc`

`source`命令还有一个别名就是`.`，注意与表示当前路径的那个点区分开，虽然形式一样，但作用和使用方式一样，上面的命令如果替换成`.`的方式就该是

`$ . ./.zshrc`

注意第一个点后面有一个空格，而且后面的文件必须指定完整的绝对或相对路径名，`source`则不需要。

与搜索相关的命令常用的有如下几个`whereis`,`which`,`find`,`locate`。

- whereis简单快速
- locate快而全
- which小而精
- find精而细

## 六、文件打包与压缩

### 使用zip打包文件夹：

```bash
$ zip -r -q -o shiyanlou.zip /home/shiyanlou
$ du -h shiyanlou.zip
$ file shiyanlou.zip
```

第一行命令中，`-r`参数表示递归打包包含子目录的全部内容，`-q`参数表示为安静模式，即不向屏幕输出信息，`-o`表示输出文件，需在其后紧跟打包输出文件名。后面使用`du`命令查看打包后文件的大小。

### 使用unzip命令解压缩zip文件

将shiyanlou.zip解压到当前目录：

`$ unzip shiyanlou.zip`

使用安静模式，将文件解压到指定目录：

`$ unzip -q shiyanlou.zip -d ziptest`

## 七、命令执行顺序控制与管道

### 命令控制顺序

简单的顺序执行你可以使用`;`来完成：

```bash
$ sudo apt-get update;sudo apt-get install some-tool;some-tool
# 让它自己运行
```

有选择性的来执行命令，比如上一条命令执行成功才继续下一条，或者不成功又该做出其它什么处理,比如我们使用`which`来查找是否安装某个命令，如果找到就执行该命令，否则什么也不做（虽然这个操作没有什么实际意义，但可帮你更好的理解一些概念）：

```bash
$ which cowsay>/dev/null && cowsay -f head-in ohch~
```

你如果没有安装`cowsay`，你可以先执行一次上述命令，你会发现什么也没发生，你再安装好之后你再执行一次上述命令，你也会发现一些惊喜。

上面的`&&`就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回`0`则执行后面的，否则不执行，你可以从`$?`环境变量获取上一次命令的返回结果。

Shell 也有一个`||`，它们的区别就在于，shell中的这两个符号除了也可用于表示逻辑与和或之外，就是可以实现这里的命令执行顺序的简单控制。`||`在这里就是与`&&`相反的控制效果，当上一条命令执行结果为`≠0($?≠0)`时则执行它后面的命令：

```bash
$ which cowsay>/dev/null || echo "cowsay has not been install, please run 'sudo apt-get install cowsay' to install"
```

除了上述基本的使用之外，我们还可以结合这`&&`和`||`来实现一些操作，比如：

```bash
$ which cowsay>/dev/null && echo "exist" || echo "not exist"
```

![逻辑流程](https://dn-anything-about-doc.qbox.me/linux_base/8-3.png)

### 管道

管道是什么,**管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)**。

管道又分为匿名管道和具名管道（这里将不会讨论在源程序中使用系统调用创建并使用管道的情况，它与命令行的管道在内核中实际都是采用相同的机制）。我们在使用一些过滤程序时经常会用到的就是匿名管道，在命令行中由`|`分隔符表示，`|`在前面的内容中我们已经多次使用到了。具名管道简单的说就是有名字的管道，通常只会在源程序中用到具名管道。下面我们就将通过一些常用的可以使用管道的"过滤程序"来帮助你熟练管道的使用。

```bash
$ ls -al /etc | less
```

通过管道将前一个命令(`ls`)的输出作为下一个命令(`less`)的输入，然后就可以一行一行地看。

`cut`命令，打印每一行的某一字段

打印/etc/passwd文件中以`:`为分隔符的第1个字段和第6个字段分别表示用户名和其家目录：

```bash
$ cut -d ':' -f 1,6 /etc/passwd
```

打印/etc/passwd文件中每一行的前N个字符：

```bash
# 前五个（包含第五个）
$ cut /etc/passwd -c -5
# 前五个之后的（包含第五个）
$ cut /etc/passwd -c 5-
# 第五个
$ cut /etc/passwd -c 5
# 2到5之间的（包含第五个）
$ cut /etc/passwd -c 2-5
```

`grep`命令是很强大的，也是相当常用的一个命令，它结合正则表达式可以实现很复杂却很高效的匹配和查找。

`grep`命令的一般形式为：

```bash
grep [命令选项]... 用于匹配的表达式 [文件]...
```

`wc` 命令用于统计并输出一个文件中行、单词和字节的数目，比如输出/etc/passwd文件的统计信息：

```bash
$ wc /etc/passwd
```

分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：

```bash
# 行数
$ wc -l /etc/passwd
# 单词数
$ wc -w /etc/passwd
# 字节数
$ wc -c /etc/passwd
# 字符数
$ wc -m /etc/passwd
# 最长行字节数
$ wc -L /etc/passwd
```

`sort` 命令功能很简单就是将输入按照一定方式排序，然后再输出,它支持的排序有按字典排序,数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序等等。

默认为字典排序：

```bash
$ cat /etc/passswd | sort
```

反转排序：

```bash
$ cat /etc/passwd | sort -r
```

按特定字段排序：

```bash
$ cat /etc/passwd | sort -t':' -k 3
```

上面的`-t`参数用于指定字段的分隔符，这里是以":"作为分隔符；`-k` 字段号用于指定对哪一个字段进行排序。这里/etc/passwd文件的第三个字段为数字，默认情况下是一字典序排序的，如果要按照数字排序就要加上`-n`参数：

```bash
$ cat /etc/passwd | sort -t':' -k 3 -n
```

## 八、数据流重定向

默认使用终端的标准输入作为命令的输入和标准输出作为命令的输出

```bash
$ cat 
（按Ctrl+C退出）
```

将`cat`的连续输出（heredoc方式）重定向到一个文件

```bash
$ mkdir Documents
$ cat > Documents/test.c <<EOF
#include <stdio.h>

int main()
{
    printf("hello world\n");
    return 0;
}

EOF
```

将一个文件作为命令的输入，标准输出作为命令的输出

```bash
$ cat Documents/test.c
```

将`echo`命令通过管道传过来的数据作为`cat`命令的输入，将标准输出作为命令的输出

```bash
$ echo 'hi' | cat
```

将`echo`命令的输出从默认的标准输出重定向到一个普通文件

```bash
$ echo 'hello shiyanlou' > redirect
$ cat redirect
```

> 管道默认是连接前一个命令的输出到下一个命令的输入，而重定向通常是需要一个文件来建立两个命令的连接

## 九、正则表达式基础

> **正则表达式**，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。

> 许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在 Perl 中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由 UNIX 中的工具软件（例如`sed`和`grep`）普及开的。正则表达式通常缩写成“regex”，单数有 regexp、regex，复数有 regexps、regexes、regexen。

> 简单的说形式和功能上正则表达式和**通配符**很像，不过它们之间又有很大差别，特别在于一些特殊的匹配字符的含义上。

### 正则式和通配符的简单例子

假设我们有这样一个文本文件，包含"shiyanlou"，和"shilouyan"这两个字符串，同样一个表达式：

`shi*`

如果这作为一个正则表达式，它将只能匹配 shi，而如果不是作为正则表达式`*`作为一个通配符，则将同时匹配这两个字符串。这是为什么呢？因为在正则表达式中`*`表示匹配前面的子表达式（这里就是它前面一个字符）零次或多次，比如它可以匹配"sh","shii","shish","shiishi"等等，而作为通配符表示匹配通配符后面任意多个任意字符，所以它可以匹配"shiyanlou"，和"shilouyan"两个字符。

### 基本语法：

一个正则表达式通常被称为一个**模式（pattern）**，为用来描述或者匹配一系列符合某个句法规则的字符串。

#### 选择

`|`竖直分隔符表示选择，例如"`boy|girl`"可以匹配"boy"或者"girl"

#### 数量限定

数量限定除了我们举例用的`*`,还有`+`加号,`?`问号,`.`点号，如果在一个模式中不加数量限定符则表示出现一次且仅出现一次：

- `+`表示前面的字符必须出现至少一次(1次或多次)，例如，"`goo+gle`",可以匹配"gooogle","goooogle"等；
- `?`表示前面的字符最多出现一次(0次或1次)，例如，"`colou?r`",可以匹配"color"或者"colour";
- `*`星号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次），例如，“`0*42`”可以匹配42、042、0042、00042等。

#### 范围和优先级

`()`圆括号可以用来定义模式字符串的范围和优先级，这可以简单的理解为是否将括号内的模式串作为一个整体。例如，"`gr(a|e)y`"等价于"`gray|grey`"，（这里体现了优先级，竖直分隔符用于选择a或者e而不是gra和ey），"`(grand)?father`"匹配father和grandfather（这里体验了范围，`?`将**圆括号内容作为一个整体匹配**）。

#### 语法（部分）

正则表达式有多种不同的风格，下面列举一些常用的作为 PCRE 子集的适用于`perl`和`python`编程语言及`grep`或`egrep`的正则表达式匹配规则：(由于markdown表格解析的问题，下面的竖直分隔符用全角字符代替，实际使用时请换回半角字符)

> PCRE（Perl Compatible Regular Expressions中文含义：perl语言兼容正则表达式）是一个用 C 语言编写的正则表达式函数库，由菲利普.海泽(Philip Hazel)编写。PCRE是一个轻量级的函数库，比Boost 之类的正则表达式库小得多。PCRE 十分易用，同时功能也很强大，性能超过了 POSIX 正则表达式库和一些经典的正则表达式库。

| 字符 | 描述 |
|--|--|
| `\` | **将下一个字符标记为一个特殊字符、或一个原义字符**。例如，“`n`”匹配字符“n”。“`\n`”匹配一个换行符。序列“`\\`”匹配“\”而“`\(`”则匹配“(”。 |
| `^` | **匹配输入字符串的开始位置**。 |
| `$` | **匹配输入字符串的结束位置**。 |
| `{n}` | n是一个非负整数。**匹配确定的n次**。例如，“`o{2}`”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 |
| `{n,}` | n是一个非负整数。**至少匹配n次**。例如，“`o{2,}`”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“`o{1,}`”等价于“`o+`”。“`o{0,}`”则等价于“`o*`”。 |
| `{n,m}` | m和n均为非负整数，其中n<=m。**最少匹配n次且最多匹配m次**。例如，“`o{1,3}`”将匹配“fooooood”中的前三个o。“`o{0,1}`”等价于“o?”。请注意在逗号和两个数之间不能有空格。 |
| `*` | **匹配前面的子表达式零次或多次**。例如，`zo*`能匹配“z”、“zo”以及“zoo”。`*`等价于`{0,}`。 |
| `+` | **匹配前面的子表达式一次或多次**。例如，“`zo+`”能匹配“zo”以及“zoo”，但不能匹配“z”。`+`等价于`{1,}`。 |
| `?` | **匹配前面的子表达式零次或一次**。例如，“`do(es)?`”可以匹配“do”或“does”中的“do”。`?`等价于`{0,1}`。 |
| `?` | **当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的**。**非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串**。例如，对于字符串“oooo”，“`o+?`”将匹配单个“o”，而“`o+`”将匹配所有“o”。 |
| `.` | **匹配除“`\n`”之外的任何单个字符**。要匹配包括“`\n`”在内的任何字符，请使用像“`(.｜\n)`”的模式。 |
| `(pattern)` | **匹配pattern并获取这一匹配的子字符串**。该子字符串用于向后引用。要匹配圆括号字符，请使用“`\(`”或“`\)`”。 |
| `x｜y` | **匹配x或y**。例如，“`z｜food`”能匹配“z”或“food”。“`(z｜f)ood`”则匹配“zood”或“food”。 |
| `[xyz]` | 字符集合（character class）。**匹配所包含的任意一个字符**。例如，“`[abc]`”可以匹配“plain”中的“a”。其中特殊字符仅有反斜线`\`保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符。 |
| `[^xyz]` | 排除型（negate）字符集合。**匹配未列出的任意字符**。例如，“`[^abc]`”可以匹配“plain”中的“plin”。 |
| `[a-z]` | 字符范围。**匹配指定范围内的任意字符**。例如，“`[a-z]`”可以匹配“a”到“z”范围内的任意小写字母字符。 |
| `[^a-z]` | 排除型的字符范围。**匹配任何不在指定范围内的任意字符**。例如，“`[^a-z]`”可以匹配任何不在“a”到“z”范围内的任意字符。 |

正则式的思维导图：

![regexMindmap](https://dn-anything-about-doc.qbox.me/linux_base/RegularExpression.png)

### grep模式匹配命令

`grep`命令用于打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。

```bash
# 将匹配以'z'开头以'o'结尾的所有字符串
$ echo 'zero\nzo\nzoo' | grep 'z.*o'
# 将匹配以'z'开头以'o'结尾，中间包含一个任意字符的字符串
$ echo 'zero\nzo\nzoo' | grep 'z.o'
# 将匹配以'z'开头,以任意多个'o'结尾的字符串
$ echo 'zero\nzo\nzoo' | grep 'zo*'
```

> 注意：其中`\n`为换行符

```bash
# grep默认是区分大小写的，这里将匹配所有的小写字母
$ echo '1234\nabcd' | grep '[a-z]'
# 将匹配所有的数字
$ echo '1234\nabcd' | grep '[0-9]'
# 将匹配所有的数字
$ echo '1234\nabcd' | grep '[[:digit:]]'
# 将匹配所有的小写字母
$ echo '1234\nabcd' | grep '[[:lower:]]'
# 将匹配所有的大写字母
$ echo '1234\nabcd' | grep '[[:upper:]]'
# 将匹配所有的字母和数字，包括0-9,a-z,A-Z
$ echo '1234\nabcd' | grep '[[:alnum:]]'
# 将匹配所有的字母
$ echo '1234\nabcd' | grep '[[:alpha:]]'
```

要通过`grep`使用**扩展正则表达式**需要加上`-E`参数，或使用`egrep`。

```bash
# 只匹配"zo"
$ echo 'zero\nzo\nzoo' | grep -E 'zo{1}'
# 匹配以"zo"开头的所有单词
$ echo 'zero\nzo\nzoo' | grep -E 'zo{1,}'
```

> 注意：推荐掌握`{n,m}`即可，`+,?,*`，这几个不太直观，且容易弄混淆。

```bash
# 匹配"www.shiyanlou.com"和"www.google.com"
$ echo 'www.shiyanlou.com\nwww.baidu.com\nwww.google.com' | grep -E 'www\.(shiyanlou|google)\.com'
# 或者匹配不包含"baidu"的内容
$ echo 'www.shiyanlou.com\nwww.baidu.com\nwww.google.com' | grep -Ev 'www\.baidu\.com'
```

> 注意：因为`.`号有特殊含义，所以需要转义。