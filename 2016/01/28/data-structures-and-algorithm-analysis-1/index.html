<!DOCTYPE html>
<html lang="default">
  <head><meta name="generator" content="Hexo 3.9.0">
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="数据结构与算法分析（一）：基础算法分析">




  <meta name="keywords" content="数据结构, 算法, java, KChen's Blog">










  <link rel="alternate" href="/atom.xml" title="KChen's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.png?v=2.10.1">



<link rel="canonical" href="http://kchen.cc/2016/01/28/data-structures-and-algorithm-analysis-1/">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.1">



  
  <script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?940f951acbfe5399f7a2816cdbdae170";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-41464607-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-41464607-2');
</script>


  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "E6WKI3ciNvoyQWfb6qdM50rJ-gzGzoHsz",
      appKey: "wVKlG50ntVertqEOw4aQEVwI"
    });
  </script>





<script>
  window.config = {"leancloud":{"app_id":"E6WKI3ciNvoyQWfb6qdM50rJ-gzGzoHsz","app_key":"wVKlG50ntVertqEOw4aQEVwI"},"toc":true,"fancybox":true,"pjax":true};
</script>

    <title> 数据结构与算法分析（一）：基础算法分析 - KChen's Blog </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="mobile-header-logo">
    <a href="/." class="logo">KChen's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">KChen's Blog</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          数据结构与算法分析（一）：基础算法分析
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-01-28
        </span>
        
        
        <span class="post-visits" data-url="/2016/01/28/data-structures-and-algorithm-analysis-1/" data-title="数据结构与算法分析（一）：基础算法分析">
          阅读次数 0
        </span>
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引论：递归例程设计的四条基本法则"><span class="toc-text">引论：递归例程设计的四条基本法则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法分析"><span class="toc-text">算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-数学基础"><span class="toc-text">1. 数学基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#时间复杂度的基本定义解释"><span class="toc-text">时间复杂度的基本定义解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重要结论"><span class="toc-text">重要结论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常见的函数分类"><span class="toc-text">常见的函数分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-要分析的问题"><span class="toc-text">2. 要分析的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-运行时间计算"><span class="toc-text">3. 运行时间计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一个简单的例子"><span class="toc-text">一个简单的例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一般法则"><span class="toc-text">一般法则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#法则1——for循环"><span class="toc-text">法则1——for循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#法则2——嵌套的for循环"><span class="toc-text">法则2——嵌套的for循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#法则3——顺序语句"><span class="toc-text">法则3——顺序语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#法则4——if-else语句"><span class="toc-text">法则4——if/else语句</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最大子序列和问题"><span class="toc-text">最大子序列和问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#算法一"><span class="toc-text">算法一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#算法二"><span class="toc-text">算法二</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#算法三"><span class="toc-text">算法三*</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#算法四"><span class="toc-text">算法四</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行时间中的对数"><span class="toc-text">运行时间中的对数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#折半查找（binary-search）"><span class="toc-text">折半查找（binary search）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#欧几里得算法"><span class="toc-text">欧几里得算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#幂运算"><span class="toc-text">幂运算</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#检验分析"><span class="toc-text">检验分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-小结"><span class="toc-text">4. 小结</span></a></li></ol></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>由于 Hexo 对 Math 的显示效果不佳，请移步到下方链接阅读这篇博客：</p>
<p><a href="https://www.zybuluo.com/fyywy520/note/277242" target="_blank" rel="noopener">数据结构与算法分析（一）：基础算法分析</a></p>
<p><img src="http://data.kchen.cc/img-mind-datastructure-1.png-960.jpg" alt="Mindmap"></p>
<a id="more"></a>
<h2 id="引论：递归例程设计的四条基本法则"><a href="#引论：递归例程设计的四条基本法则" class="headerlink" title="引论：递归例程设计的四条基本法则"></a>引论：递归例程设计的四条基本法则</h2><ol>
<li><strong>基准情形</strong>。必须总要有某些基准情形，它无需递归就能解出。</li>
<li><strong>不断推进</strong>。对于那些需要递归求解的情形，每一次递归调用都必须要使状况朝向一种基准情形推进。</li>
<li><strong>设计法则</strong>。假设所有的递归调用都能运行。</li>
<li><strong>合成效益法则</strong>（compound interest rule）。<span id="CIR"></span>在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。</li>
</ol>
<blockquote>
<p>使用递归计算诸如裴波那切数列之类简单的数学函数的值的想法一般来说并不是一个好主意，其道理正是根据第四条法则。（后面将会介绍）</p>
</blockquote>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>解决的主要问题：</p>
<ul>
<li>如何估计一个程序所需要的时间。</li>
<li>如何将一个程序的运行时间从天或年降低到秒甚至更少。</li>
<li>粗心使用递归的后果。</li>
<li>将一个数自乘得到其幂，以及计算两个数的最大公因数的非常有效的算法。</li>
</ul>
<h3 id="1-数学基础"><a href="#1-数学基础" class="headerlink" title="1. 数学基础"></a>1. 数学基础</h3><h4 id="时间复杂度的基本定义解释"><a href="#时间复杂度的基本定义解释" class="headerlink" title="时间复杂度的基本定义解释"></a>时间复杂度的基本定义解释</h4><ol>
<li>$T(N)=O(f(N))$表示$T(N)$的增长率小于或等于$f(N)$的增长率，这种记法称为<strong>大O标记法</strong>。</li>
<li>$T(N)=\Omega(g(N))$表示$T(N)$的增长率大于或等于$g(N)$的增长率。</li>
<li>$T(N)=\Theta(h(N))$表示$T(N)$的增长率等于$h(N)$的增长率。</li>
<li>$T(N)=o(p(N))$表示$T(N)$的增长率小于$p(N)$的增长率，称为<strong>小o标记法</strong>，他不同于大O，因为大O包含增长率相同的情况。</li>
<li>$T(N)=O(p(N))$且$T(N)\neq\Theta(p(N))$则$T(n)=o(p(N))$。</li>
</ol>
<h4 id="重要结论"><a href="#重要结论" class="headerlink" title="重要结论"></a>重要结论</h4><ul>
<li>法则1：<br>  大O标记对加法和乘法是齐次的。</li>
<li>法则2：<br>  如果$T(N)$是一个$k$次多项式，则$T(N)=\Theta(N^k)$</li>
<li>法则3：<br>  对任意常数$k$，$\mathrm{log}^kN=O(N)$。它告诉我们对数增长得非常缓慢。</li>
<li>法则4：<br>  我们总能通过计算极限$\mathrm{lim}_{N\to\infty}f(N)/g(N)$来确定两个函数的相对增长率，有时可能会需要用到洛必达法则[^LHospital]。</li>
</ul>
<h4 id="常见的函数分类"><a href="#常见的函数分类" class="headerlink" title="常见的函数分类"></a>常见的函数分类</h4><table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$c$</td>
<td style="text-align:center">常数</td>
</tr>
<tr>
<td style="text-align:center">$\mathrm{log}N$</td>
<td style="text-align:center">对数</td>
</tr>
<tr>
<td style="text-align:center">$\mathrm{log}^2N$</td>
<td style="text-align:center">对数平方的</td>
</tr>
<tr>
<td style="text-align:center">$N$</td>
<td style="text-align:center">线性的</td>
</tr>
<tr>
<td style="text-align:center">$N\mathrm{log}N$</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">$N^2$</td>
<td style="text-align:center">二次的</td>
</tr>
<tr>
<td style="text-align:center">$N^3$</td>
<td style="text-align:center">三次的</td>
</tr>
<tr>
<td style="text-align:center">$2^N$</td>
<td style="text-align:center">指数的</td>
</tr>
</tbody>
</table>
<h3 id="2-要分析的问题"><a href="#2-要分析的问题" class="headerlink" title="2. 要分析的问题"></a>2. 要分析的问题</h3><p>典型的情形是，输入的大小是主要的考虑方面。我们定义两个函数$T_{avg}(N)$和$T_{worst}(N)$，分别为算法对于输入量$N$所花费的<strong>平均运行时间</strong>和<strong>最坏情况的运行时间</strong>。</p>
<h3 id="3-运行时间计算"><a href="#3-运行时间计算" class="headerlink" title="3. 运行时间计算"></a>3. 运行时间计算</h3><h4 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h4><p>这里是计算$\sum_{i=1}^{N}i^3$的一个简单的程序片段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> partialSum;</span><br><span class="line">    </span><br><span class="line">    partialSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        partialSum += i * i * i;</span><br><span class="line">    <span class="keyword">return</span> partialSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析如下：</p>
<blockquote>
<p>第4行和第8行各占1个时间单位。 第6行每次执行占用4个时间单位（2个乘法、1个加法、1个赋值），而执行$N$次共占用$4N$个时间单位。<br>第5行初始化时占用1个时间单位，所有测试为$N+1$个时间单位，自增运算为$N$个时间单位。<br>忽略调用方法和返回值的开销，得到的总量是$6N+4$个时间单位，因此，我们说该方法是$O(N)$的。</p>
</blockquote>
<p>为了简化以上的分析工作，可以利用如下若干一般法则。</p>
<h4 id="一般法则"><a href="#一般法则" class="headerlink" title="一般法则"></a>一般法则</h4><h5 id="法则1——for循环"><a href="#法则1——for循环" class="headerlink" title="法则1——for循环"></a>法则1——for循环</h5><p>一个<code>for</code>循环的运行时间至多是该<code>for</code>循环内部那些语句（包括测试）的运行时间乘以迭代次数。</p>
<h5 id="法则2——嵌套的for循环"><a href="#法则2——嵌套的for循环" class="headerlink" title="法则2——嵌套的for循环"></a>法则2——嵌套的for循环</h5><p>从里向外分析这些循环，内部语句的总的执运行时间等于语句的运行时间乘以所有<code>for</code>循环大小的乘积。</p>
<blockquote>
<p>例如，下列程序片段为$O(N^2)$<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">&gt;   <span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">&gt;       k ++;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="法则3——顺序语句"><a href="#法则3——顺序语句" class="headerlink" title="法则3——顺序语句"></a>法则3——顺序语句</h5><p>加和即可，也即各语句的最大值就是运行时间。</p>
<h5 id="法则4——if-else语句"><a href="#法则4——if-else语句" class="headerlink" title="法则4——if/else语句"></a>法则4——if/else语句</h5><p>对于程序片段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( cond )</span><br><span class="line">    S1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    S2</span><br></pre></td></tr></table></figure></p>
<p>一个<code>if/else</code>语句的运行时间从不超过判断的运<code>S1</code>和<code>S2</code>中运行时间长者的总的运行时间。</p>
<p>分析的基本策略是从内部（或最深层的部分）向外展开的。如果有方法调用，首先要分析方法调用。如果有<strong>递归过程</strong>，则需要看其是否只是<code>for</code>循环的变形，如下程序只是一个简单的循环从而其运行时间是$O(N)$：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * factorial(n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当递归正常调用时，将其转换成为一个<code>for</code>循环是相当困难的，这样的情况下分析将涉及求解一个递推关系，例如下面的程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于$N\ge2$，有下列关于<code>fib(n)</code>的运行时间公式：<br>$$T(N)=T(N-1)+T(N-2)+2$$<br>借由归纳法可以证明$T(N)\ge fib(N)$且$fib(N)\ge(3/2)^N$。从而这个程序的运行时间将以<strong>指数</strong>的速度增长。</p>
<p>这个程序之所以运行缓慢，是因为其存在了大量的多余工作要做，违反了<strong><a href="#CIR" title="在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。">合成效益法则</a></strong>。试想，<code>fib(3)</code>调用了<code>fib(2)</code>和<code>fib(1)</code>，而<code>fib(4)</code>又调用了<code>fib(3)</code>和<code>fib(2)</code>，如此下去其中被抛弃的信息量合成起来导致了大量的运行时间。所以，「<strong>计算任何事情不要超过一次</strong>」。</p>
<h4 id="最大子序列和问题"><a href="#最大子序列和问题" class="headerlink" title="最大子序列和问题"></a>最大子序列和问题</h4><p>给定（可能有负的）整数$A_1,A_2,\cdots,A_N$，求$\sum_{k=i}^{j}A_k$的最大值。（为方便起见，如果所有整数均为负数，则最大子序列的和为负数0）</p>
<blockquote>
<p>例如：对于输入-2，11，-4，13，-5，-2，答案为20（从$A_2$到$A_4$）。</p>
</blockquote>
<p>对于这个问题我们将讨论求解的四种算法，它们的性能如下：</p>
<table><br>    <tr><br>        <td rowspan="2">输入大小</td><br>        <td colspan="4">算法时间</td><br>    </tr><br>    <tr><br>        <td>1<br>$O(N^3)$</td><br>        <td>2<br>$O(N^2)$</td><br>        <td>3<br>$O(N\mathrm{log}N)$</td><br>        <td>4<br>$O(N)$</td><br>    </tr><br>    <tr><br>        <td>N=10</td><br>        <td>0.000 009</td><br>        <td>0.000 004</td><br>        <td>0.000 006</td><br>        <td>0.000 003</td><br>    </tr><br>    <tr><br>        <td>N=100</td><br>        <td>0.002 580</td><br>        <td>0.000 109</td><br>        <td>0.000 045</td><br>        <td>0.000 006</td><br>    </tr><br>    <tr><br>        <td>N=1 000</td><br>        <td>2.281 013</td><br>        <td>0.010 203</td><br>        <td>0.000 485</td><br>        <td>0.000 031</td><br>    </tr><br>    <tr><br>        <td>N=10 000</td><br>        <td>NA</td><br>        <td>1.232 9</td><br>        <td>0.005 712</td><br>        <td>0.000 317</td><br>    </tr><br>    <tr><br>        <td>N=100 000</td><br>        <td>NA</td><br>        <td>135</td><br>        <td>0.064 618</td><br>        <td>0.003 206</td><br>    </tr><br></table>

<p>不难看出，对于小量的输入，这些算法都在眨眼之间完成，因此如果只是小量输入的情形，那么花费大量的努力去设计聪明的算法恐怕就太不值得了。另一方面，进来对于重写那些不再合理的基于小输入量假设而在五年前变西欧的程序确实存在巨大的市场。对于大量的输入，算法4显然是最好的选择。</p>
<h5 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cubic maximum contiguous subsequence sum algorithm.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubSum1</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; a.length; j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> thisSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">				thisSum += a[k];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (thisSum &gt; maxSum) &#123;</span><br><span class="line">				maxSum = thisSum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法只是穷举所有的可能，易证明，该算法主要为第12行的加等运算在深度为三级的循环中执行$O(N^3)$的运算。</p>
<blockquote>
<p>事实上：<br>$$\sum_{i=0}^{N-1}\sum_{j=i}^{N-1}\sum_{k=i}^{j}1=\frac{N^3+3N^2+2N}{6}$$</p>
</blockquote>
<h5 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h5><p>我们可以通过撤除一个<code>for</code>循环来避免三次的运行时间，也就是说算法一中11行和12行的计算是过分消耗了的，改进后的算法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Quadratic maximum contiguous subsequence sum algorithm.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubSum2</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> thisSum = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; a.length; j++) &#123;</span><br><span class="line">			thisSum += a[j];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ( thisSum &gt; maxSum)</span><br><span class="line">				maxSum = thisSum;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法二显然是$O(N^2)$的，其分析比算法一还简单。</p>
<h5 id="算法三"><a href="#算法三" class="headerlink" title="算法三*"></a>算法三*</h5><p>算法三采用一种「<strong>分治（divide-and-conquer）</strong>」策略。其想法是把问题分成两个大致相等的子问题，然后递归地对他们求解，这是「分」的部分。「治」阶段将两个子问题的解修补到一起并可能再做些少量的附加工作，最后得到整个问题的解。</p>
<p>在这个例子中，最大子序列可能出现在三处，整个数据的左半部、右半部或者横跨中间。前两种情况可以直接递归求解，第三种情况可以通过求解左半部分的右侧最大序列和以及右半部分的左侧最大序列和而得到。</p>
<p>考虑如下输入：</p>
<table><br>    <tr><br>        <td colspan="4">前半部分</td><br>        <td colspan="4">后半部分</td><br>    </tr><br>    <tr><br>        <td>4</td><br>        <td>-3</td><br>        <td>5</td><br>        <td>-2</td><br>        <td>-1</td><br>        <td>2</td><br>        <td>6</td><br>        <td>-2</td><br>    </tr><br></table>

<p>其前半部分的最大子序列和为6（$A_1$到$A_3$）而后半部分的最大子序列和为8（$A_6$到$A_7$）。</p>
<p>前半部分的右侧最大序列和为4（$A_1$到$A_4$），而后半部分的左侧最大序列和为7（$A_5$到$A_7$）。因此，横跨这两部分的最大和为$4+7=11$（$A_1$到$A_7$）。</p>
<p>故而此例中，最大子序列和就是11。</p>
<p>下面是该算法的一种实现手段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursive maximum contiguous subsequence sum algorithm.</span></span><br><span class="line"><span class="comment"> * Finds maximum sum in subarray spanning a[left..right].</span></span><br><span class="line"><span class="comment"> * Does not attempt to maintain actual best sequence. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSumRec</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left == right) &#123;	<span class="comment">//Base case</span></span><br><span class="line">		<span class="keyword">if</span> (a[left] &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> a[left];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> maxLeftSum = maxSumRec(a, left, center);</span><br><span class="line">	<span class="keyword">int</span> maxRightSum = maxSumRec(s, center, right);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> maxLeftBorderSum = <span class="number">0</span>, leftBorderSum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = center; i &gt;= left; i--) &#123;</span><br><span class="line">		leftBorderSum += a[i];</span><br><span class="line">		<span class="keyword">if</span> (leftBorderSum &gt; maxLeftBorderSum)</span><br><span class="line">			maxLeftBorderSum = leftBorderSum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> maxRightBorderSum = <span class="number">0</span>, rightBorderSum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = center; i &lt;= right; i++) &#123;</span><br><span class="line">		rightBorderSum += a[i];</span><br><span class="line">		<span class="keyword">if</span> (rightBorderSum &gt; maxRightBorderSum)</span><br><span class="line">			maxRightBorderSum = rightBorderSum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> max3(maxLeftSum, maxRightSum, maxLeftBorderSum + maxRightBorderSum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Driver for divide-and-conquer maximum contiguous</span></span><br><span class="line"><span class="comment"> * subsequence sum algorithm.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubSum3</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> maxSumRec(a, <span class="number">0</span>, a.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序解析：</p>
<p>递归调用的一般形式是传递输入数组以及左边界和右边界，它们界定数组要被处理的部分。单行驱动程序通过传递数组以及边界<code>0</code>和<code>N-1</code>而将递归过程启动。</p>
<p>程序的第7到12行描述了一种基准情况，第15和16行调用两个递归过程，第18到23和第25到30行分别给出了到达中间分界处的两个和数的最大值，<code>max3</code>（未定义）给出了算法中三个部分的最大值。</p>
<p>通过递归过程的调用，我们不难看出：</p>
<p>$$T(1)=O(1)\<br>T(N)=T(N/2)+O(N)$$</p>
<p>经过推导，也可知$T(N)=N\mathrm{log}N+N=O(N\mathrm{log}N)$。</p>
<p>若非算法四给出了一个线性时间运行的解法，这个算法就会使体现递归为例的极好的范例了。</p>
<h5 id="算法四"><a href="#算法四" class="headerlink" title="算法四"></a>算法四</h5><p>我们不妨这样来理解最大序列和的问题：如果子序列由一个负数<code>a[i]</code>开头，那么这个子序列的和必然不能是最大的,因为<code>a[i+1]</code>开头的子序列必然更大，所以<code>i</code>可以推进到<code>i+1</code>。推广一下，如果<code>a[i]</code>到<code>a[j]</code>的子序列和是负数，那么包含这个子序列的序列和也不可能是最大的，因此直接把<code>i</code>推进到<code>j+1</code>是没有风险的：我们的最优解也不会错过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Linear-time maximum contiguous subsequence sum algorithm.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubSum4</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maxSum = <span class="number">0</span>, thisSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">		thisSum += a[j];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (thisSum &gt; maxSum)</span><br><span class="line">			maxSum = thisSum;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (thisSum &lt; <span class="number">0</span>)</span><br><span class="line">			thisSum = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法是许多聪明算法的典型：<strong>运行时间是显而易见的，但正确性则不那么容易看出来</strong>。</p>
<p>该算法附带的一个优点是，它只对数据进行一次扫描，一旦数组被读入并处理，就不再需要被记忆。不仅如此，在任意时刻，算法都能对他已经读入的数据给出子序列问题的正确答案（其他算法不具备这个特性）。具有这种特性的叫做<strong>联机算法（on-line algorithm）</strong>。</p>
<blockquote>
<p>仅需要常量空间并以线性时间运行的联机算法几乎是完美的算法！</p>
</blockquote>
<h4 id="运行时间中的对数"><a href="#运行时间中的对数" class="headerlink" title="运行时间中的对数"></a>运行时间中的对数</h4><p>分析算法最混乱的地方就是在对数上面，某些分治算法将以$O(N\mathrm{log}N)$运行。此外，对数最常出现的规律可以概括为下列一般法则：</p>
<blockquote>
<p>如果一个算法用常数时间将问题的大小削减为其一部分（通常是1/2），那么该算法就是$O(\mathrm{log}N)$。另一方面，如果使用常数时间只是把问题减少一个一个常数的数量（如将问题减少1），那么这种算法就是$O(N)$的。</p>
</blockquote>
<p>通常我们计算这些算法时都假设输入数据已经提前读入。</p>
<h5 id="折半查找（binary-search）"><a href="#折半查找（binary-search）" class="headerlink" title="折半查找（binary search）"></a>折半查找（binary search）</h5><p>给定一个整数$X$和整数$A_0,A_1,\cdots,A_{N-1}$，后者已经预先排序并在内存中，求下标$i$使得$A_i=X$，如果$X$不在序列中，则返回<code>-1</code>。</p>
<p>最明显的解法是从头到尾扫描数据，其运行时间是线性的。然而这个算法并没有利用到序列已经排序的事实。一个好的策略应该是判断$X$是不是居中的元素，如果是则返回，如果大于居中的元素，则在左半部分中继续寻找，如果小于居中的元素，则在右半部分中继续寻找：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs the standard binary search.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> index where item is found, or -1 if not found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;AnyType extends Comparable&lt;? <span class="keyword">super</span> AnyType&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(AnyType[] a, AnyType x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> low = <span class="number">0</span>, high = a.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (a[mid].compareTo(x) &lt; <span class="number">0</span>) </span><br><span class="line">			low = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[mid].compareTo(x) &gt; <span class="number">0</span>) </span><br><span class="line">			high = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NOT_FOUND;	<span class="comment">//NOT_FOUND is defined as -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序中每次迭代所有工作花费$O(1)$的时间，因此需要分析循环次数。循环是从<code>high</code>-<code>low</code>$=N-1$开始并在<code>high</code>-<code>low</code>$\le-1$时结束，每次循环后，<code>high</code>-<code>low</code>的值至少会折半，因此不难看出，程序的运行时间是$O(\mathrm{log}N)$。</p>
<h5 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h5><p>第二个例子是计算最大公因数的欧几里得算法。两个整数的最大公因数（$gcd$）是同时整除二者的最大整数。于是，$gcd(50,15)=5$:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> m, <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">long</span> rem = m % n;</span><br><span class="line">		m = n;</span><br><span class="line">		n = rem;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法连续计算余数直到余数是0为止，最后的非零余数就是最大公因数。因此如果<code>m</code>=1989和<code>n</code>=1590，则余数序列是399，393，6，3，0，从而$gcd(1989,1590)=3$。</p>
<p>可以证明，在两次迭代后，余数最多是原数值的一半，所以迭代次数至多是$2\mathrm{log}N=O(\mathrm{log}N)$。</p>
<blockquote>
<p>事实上，欧几里得算法在平均情况下的性能需要大量篇幅的高复杂度数学分析，其迭代的平均次数约为$(12\cdot\mathrm{ln}2\cdot\mathrm{ln}N)/\pi^2+1.47$。</p>
</blockquote>
<h5 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h5><p>最后一个例子是处理一个整数的幂。计算$X^N$的明显算法是进行$N-1$次乘法自乘。有一种递归算法效果更好。$N\le1$是基准情形。否则，若$N$是偶数则$X^N=X^{N/2}\cdot X^{N/2}$，若$N$是奇数则$X^N=X^{(N-1)/2}\cdot X^{(N-1)/2}\cdot X$。</p>
<p>显然，所需要的乘法次数最多是$2\mathrm{log}N$：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">if</span> (isEven(n))</span><br><span class="line">		<span class="keyword">return</span> pow(x * x, n / <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> pow(x * x, n / <span class="number">2</span>) * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实上述程序有很多可以调整之处，例如第4行和第5行可以不必要，第9行也可以改写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> pow(x, n - <span class="number">1</span>) * x;</span><br></pre></td></tr></table></figure>
<p>但如果把第7行改为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> pow(x, n / <span class="number">2</span>) * pow(x, n / <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>则会使得程序的效率下降因为此时有两个$N/2$的递归调用而不是一个，其运行时间将不再是$O(\mathrm{log}N)$。</p>
<h4 id="检验分析"><a href="#检验分析" class="headerlink" title="检验分析"></a>检验分析</h4><p>一旦分析过后，就要想办法检验分析是否正确，常用的办法是编程来实际观察到运行时间，一般来说，当$N$扩大一倍时：</p>
<ul>
<li>线性程序的运行时间乘以2</li>
<li>二次程序的运行时间乘以4</li>
<li>三次程序的运行时间乘以8</li>
<li>以对数时间运行的程序其运行时间加了一个常数</li>
<li>以$O(N\mathrm{log}N)$运行的程序其运行时间则比二倍稍多一些</li>
</ul>
<blockquote>
<p>单凭纯时间区分线性程序还是$O(N\mathrm{log}N)$是有一定难度的。</p>
</blockquote>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>至此，我们已经通过实例了解了如何简单地对算法的复杂性进行分析。</p>
<p>[^LHospital]: 洛必达法则（L ‘Hospital’s rule）说的是，若$\mathrm{lim}<em>{N\to\infty}f(N)=\infty$且$\mathrm{lim}</em>{N\to\infty}g(N)=\infty$，则$\mathrm{lim}<em>{N\to\infty}f(N)/g(N)=\mathrm{lim}</em>{N\to\infty}f’(N)/g’(N)$。</p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://kchen.cc">Kun Chen</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://kchen.cc/2016/01/28/data-structures-and-algorithm-analysis-1/">http://kchen.cc/2016/01/28/data-structures-and-algorithm-analysis-1/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
  <div class="post-reward">
    <input type="checkbox" name="reward" id="reward" hidden>
    <label class="reward-button" for="reward">赞赏支持</label>
    <div class="qr-code">
      
      
        <label class="qr-code-image" for="reward">
          <img class="image" src="/image/reward/wechat.png" title="wechat">
        </label>
      
      
        <label class="qr-code-image" for="reward">
          <img class="image" src="/image/reward/alipay.png" title="alipay">
        </label>
      
    </div>
  </div>

    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/数据结构/">数据结构</a>
            
              <a href="/tags/算法/">算法</a>
            
              <a href="/tags/java/">java</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2016/03/19/alfred-workflow-for-markdown-image-on-qiniu/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">利用Alfred Workflow快速上传粘贴板图片至七牛图床并在Markdown中引用</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2015/12/02/vpn-shunt/">
        <span class="next-text nav-default">通过路由表进行VPN国内外分流的办法</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:kchen2991@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://www.facebook.com/quentin.chenkun" class="iconfont icon-facebook" title="facebook"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://github.com/kchen0x" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/chen-kun-92-07/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    
      
    

    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2021

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Kun Chen</span>
    <span class="division">|</span>
    <span> <a href="https://beian.miit.gov.cn/" target="_blank">京ICP备17053524号</a></span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://kchen.cc/2016/01/28/data-structures-and-algorithm-analysis-1/';
        this.page.identifier = '2016/01/28/data-structures-and-algorithm-analysis-1/';
        this.page.title = '数据结构与算法分析（一）：基础算法分析';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//kchen.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.1"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  </body>
</html>
